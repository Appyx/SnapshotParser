//
//  SnapshotParser.swift
//  Snowlink
//
//  Created by Robert Gstöttner on 13/08/2017.
//  Copyright © 2017 appyx. All rights reserved.
//

import Foundation
import FirebaseDatabase


/// This parser parses the snapshot of a firebase reference into a swift class.
/// The destination class has to implement the ParsableObject/ParsableSnapshot protocol.
/// The destination classes can be nested.
///
/// Each field of the snapshot has to be bound to a corresponding field in the class or
/// an error will be thrown.
class SnapshotParser {

    fileprivate var primaryKey: String = "id"

    init() {
    }

    init(withKey: String) {
        primaryKey = withKey
    }

    /// Parses the firebase-snapshot and returns a object of the specified type.
    /// The fields/objects/lists can be bound in the method:
    ///
    /// bindProperties(binder: SnapshotParser.Binder)
    func parseSnapshot<T: ParsableSnapshot>(snap: DataSnapshot, type: T.Type) throws -> T {
        let object = T()
        if let node = snap.value as? [String: Any] {
            return try parseNode(id: snap.key, node: node)
        }
        return object
    }

    func parseObject<T: ParsableObject>(snap: DataSnapshot, type: T.Type) throws -> T {
        let object = T()
        if let node = snap.value as? [String: Any] {
            return try parseObject(node: node)
        }
        return object
    }

    /// Parses the firebase-snapshot and returns a list of objects of the specified type.
    /// The fields/objects/lists can be bound in the method:
    ///
    /// bindProperties(binder: SnapshotParser.Binder)
    func parseAsList<T: ParsableSnapshot>(snap: DataSnapshot, type: T.Type) throws -> Array<T> {
        var list = [T]()
        if let value = snap.value as? [String: Any] {
            list = try parseList(list: value)
        }
        return list
    }

    /// Serializes the supplied object into a dictionary ready to use with the firebase sdk.
    /// The id value of the outer snapshot is ignored in this case because normally a new autogenerated id is used.
    func serialize<T: ParsableObject>(object: T) -> [String: Any] {
        let binder = Binder(primary: primaryKey)
        object.bindProperties(binder: binder)
        return binder.getDictionary()
    }

    private func parseNode<T: ParsableSnapshot>(id: String, node: [String: Any]) throws -> T {
        let object = T()
        let binder = Binder(key: primaryKey, value: id)
        object.bindProperties(binder: binder)
        try binder.checkForError()

        for (key, value) in node {
            let binder = Binder(key: key, value: value)
            object.bindProperties(binder: binder)
            try binder.checkForError()
        }
        return object
    }

    private func parseList<T: ParsableSnapshot>(list: Any) throws -> Array<T> {
        var result = [T]()
        if let list = list as? [String: Any] {
            for (key, value) in list {
                if let value = value as? [String: Any] {
                    try result.append(parseNode(id: key, node: value))
                }
            }
        }
        return result
    }

    private func parseObject<T: ParsableObject>(node: Any) throws -> T {
        let object = T()
        if let node = node as? [String: Any] {
            for (key, value) in node {
                let binder = Binder(key: key, value: value)
                object.bindProperties(binder: binder)
                try binder.checkForError()
            }
        }
        return object
    }


    /// The binder is used to assign the parsed values to their corresponding fields/objects/lists.
    class Binder {

        private let parser = SnapshotParser()
        private var key: String? = nil
        private var value: Any? = nil
        private var isBound = false
        private var error: ParseError? = nil
        private var dict: [String: Any] = [:]
        private var serialize = false
        private var primaryKey = "id"

        fileprivate init(primary: String) {
            primaryKey = primary
            serialize = true
        }

        fileprivate func getDictionary() -> [String: Any] {
            return dict
        }

        fileprivate init(key: String, value: Any) {
            self.key = key
            self.value = value
        }

        fileprivate func checkForError() throws {
            if (isBound == false) {
                if let error = error {
                    throw error
                } else {
                    throw ParseError.bindingFailed("unable to bind the property: \(key!)")
                }
            }
        }

        /// Binds the value of a primitive type identified by the name to the corresponding field.
        /// The field is passed by reference.
        /// If the name does not match an error will be thrown.
        func bindField<T>(name: String, field: inout T?) {
            if (serialize) {
                if (name == primaryKey) {
                    return
                }
                dict.updateValue(field! as Any, forKey: name)
                return
            }
            if (key == name) {
                field = value as? T
                isBound = true
            }
        }

        /// Binds the value of a primitive type identified by the name to the corresponding field.
        /// The field is passed by reference.
        /// If the name does not match an error will be thrown.
        /// Additionally it is possible to define a mapper function to convert
        /// the primitive type of the value into some other type. In this case a reverse mapper has to be defined in order
        /// to reverse the process in case of serialisation
        ///
        /// This is necessary if the resulting field cannot be cast into the desired type.
        /// (Maybe it requires a constructor to create an instance e.g. enum)
        func bindField<T>(name: String, field: inout T?, mapper: (Any) -> T?, reverseMapper: (T?) -> Any) {
            if (serialize) {
                dict.updateValue(reverseMapper(field), forKey: name)
                return
            }
            if (key == name) {
                field = mapper(value!)
                isBound = true
            }
        }

        /// Binds the list identified by the name to the correct field.
        /// A list can contain multiple snapshots.
        /// The list is passed by reference.
        /// The method parses the contents of the list recursivley
        ///
        /// If the name does not match an error will be thrown.
        func bindList<T: ParsableSnapshot>(name: String, list: inout Array<T>?) {
            if (serialize) {
                var subDict = [String: Any]()
                for elem in list! {
                    let binder = Binder(primary: primaryKey)
                    elem.bindProperties(binder: binder)
                    subDict.updateValue(binder.dict, forKey: elem.id!)
                }
                dict.updateValue(subDict, forKey: name)
                return
            }
            if (key == name) {
                do {
                    try list = parser.parseList(list: value!)
                    isBound = true
                } catch let error {
                    self.error = error as? ParseError
                }
            }
        }

        /// Binds the object identified by the name to the correct field.
        /// The object is a snapshot where the key is ignored
        /// The object is passed by reference.
        /// The method parses the contents of the object recursivley
        ///
        /// If the name does not match an error will be thrown.
        func bindObject<T: ParsableObject>(name: String, field: inout T?) {
            if (serialize) {
                let binder = Binder(primary: primaryKey)
                field?.bindProperties(binder: binder)
                dict.updateValue(binder.dict, forKey: name)
                return
            }
            if (key == name) {
                do {
                    try field = parser.parseObject(node: value!)
                    isBound = true
                } catch let error {
                    self.error = error as? ParseError
                }
            }
        }

        /// Binds all previously unbinded values and their keys into a dictionary.
        /// This method can be used as a fallback mechanism if some values were not bound.
        /// This is useful if there are keys in the snapshot which are generated hash codes for example or
        /// if the name of the key is not known in advance.
        ///
        /// This method throws an exception if different types are used for key-value-pairs.
        func bindDictionary<K, V>(name: String, dict: inout [K: V]?) {
            if (serialize) {
                for (k, v) in dict! {
                    self.dict.updateValue(v, forKey: k as! String)
                }
                return
            }
            if let value = value as? V, let key = key as? K {
                if (dict == nil) {
                    dict = [K: V]()
                }
                dict?.updateValue(value, forKey: key)
                isBound = true
            } else {
                self.error = ParseError.bindingFailed("unable to bind the dictionary named: \(name)")
            }
        }
    }

    enum ParseError: Error {
        case bindingFailed(String)
    }
}

/// Used for parsing a snapshot into an swift object.
/// A snapshot contains a key(String) and a value([String:Any])
///
/// e.g: "123456789123": {"name":"bob", "isFancy":true, "counter":13}
///
/// The final object has to contain at least an id-property for the key.
protocol ParsableSnapshot: ParsableObject {
    var id: String? { get set }
}

/// Used for parsing an object without a key into an object.
/// Same as the ParsableSnapshot but the key is ignored.
protocol ParsableObject {
    init()
    func bindProperties(binder: SnapshotParser.Binder)
}


